# 文本处理

## string--常见的字符串操作

字符串常量：

+ string.ascii_letters：英文26个字母的小写和大写组合。
+ string.ascii_lowercase：英文26个字母的小写
+ string.ascii_uppercase：英文26个字母的大写
+ string.digits：10进制数字组成的字符串
+ string.hexdigits：16进制数字组成的字符串
+ string.octdigits：8进制数字组成的字符串
+ string.punctuation：ASCII字符串的标点符号
+ string.printable：可打印的ASCII字符串
+ string.whitespace：所有被视为空格的ASCII字符的字符串

class string.Formatter：与format()格式化函数作用相似，可以自定义字符串格式，它们共享格式字符串的相同语法，但该类的子类可以定义自己的格式字符串语法。

class string.Template(template)：模板字符串，提供了更简单的字符串替换。一般用于国际化。

string.capwords(s, sep=None)：使用str.split()将参数s拆分为单词，再使用str.capitalize()将单词首字母大写，最后使用str.join()连接。

## re正则表达式

模式和被搜索的字符串既可以是 Unicode 字符串 (str) ，也可以是8位字节串 (bytes)。但是，Unicode 字符串与8位字节串不能混用。
正则表达式使用反斜杠（'\'）来表示特殊形式，或者把特殊字符转义成普通字符。 而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突。解决办法是对于正则表达式样式使用Python的原始字符串表示法：在带有 'r' 前缀的字符串字面值中，反斜杠不必做任何特殊处理。因此 r"\n" 表示包含 '\' 和 'n' 两个字符的字符串，而 "\n" 则表示只包含一个换行符的字符串。模式在 Python 代码中通常都会使用这种原始字符串表示法来表示。
第三方模块 regex , 提供了与标准库 re 模块兼容的API接口, 同时还提供了额外的功能和更全面的Unicode支持。

特殊字符简要说明：

+ .：(点)在默认模式，匹配除了换行的任意字符。如果指定了标签 DOTALL，它将匹配包括换行符的任意字符。
+ ^：(插入符号)匹配字符串的开头，并且在 MULTILINE 模式也匹配换行后的首个符号。
+ $：匹配字符串尾或者换行符的前一个字符，在 MULTILINE 模式匹配换行符的前一个字符。
+ *：对它前面的正则式匹配0到任意次重复，尽量多的匹配字符串。
+ +：对它前面的正则式匹配1到任意次重复。
+ ?：对它前面的正则式匹配0到1次重复。
+ *?, +?, ??：这些修饰符都是贪婪的；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为，在修饰符之后添加 ? 将使样式以非贪婪模式或者 :dfn:最小方式进行匹配；尽量少的字符将会被匹配。
+ {m}：对其之前的正则式指定匹配 m 个重复；少于 m 的话就会导致匹配失败。
+ {m, n}：对正则式进行 m 到 n 次匹配，在 m 和 n 之间取尽量多。忽略 m 意为指定下界为0，忽略 n 指定上界为无限次。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。
+ {m,n}?：前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。
+ \：转义特殊字符（允许匹配'*', '?', 或者此类其他），或者表示一个特殊序列。就算是最简单的表达式，也要使用原始字符串。
+ []：用于表示一个字符集合。在一个集合中：
  + 字符可以单独列出，比如 [amk] 匹配 'a'， 'm'， 或者 'k'。
  + 可以表示字符范围，通过用 '-' 将两个字符连起来。比如 [a-z] 将匹配任何小写ASCII字符， [0-5][0-9] 将匹配从 00 到 59 的两位数字， [0-9A-Fa-f] 将匹配任何十六进制数位。如果 - 进行了转义（比如 [a\-z]）或者它的位置在首位或者末尾（如 [-a] 或 [a-]），它就只表示普通字符'-'。
  + 特殊字符在集合中，失去它的特殊含义。比如[(+*)]只会匹配这几个字符'(', '+', '*', ')'。
  + 字符类如 \w 或者 \S 在集合内可以接受，它们可以匹配的字符由 ASCII 或者 LOCALE 模式决定。
  + 不在集合范围内的字符可以通过取反来进行匹配。如果集合首字符是 '^' ，所有不在集合内的字符将会被匹配，比如 [^5] 将匹配所有字符，除了'5'，[^^] 将匹配所有字符，除了'^'。 ^ 如果不在集合首位，就没有特殊含义。
  + 在集合内要匹配一个字符 ']'，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如，`[()[\]{}]` 和 `[]()[{}]` 都可以匹配括号。
+ |:A|B，A 和 B 可以是任意正则表达式，创建一个正则表达式，匹配 A 或者 B。任意个正则表达式可以用 '|' 连接。它也可以在组合内使用。扫描目标字符串时，'|' 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 A 匹配成功，B 就不再进行匹配，即便它能产生一个更好的匹配。如果要匹配 '|' 字符，使用 \|， 或者把它包含在字符集里，比如 [|].
+ (...)：（组合）匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 \number 转义序列进行再次匹配。要匹配字符'(' 或者 ')', 用 \( 或 \), 或者把它们包含在字符集合里: [(], [)]。
+ (?…)：这是个扩展标记法。'?' 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合；`(?P<name>...)`是唯一的例外。

由 '\' 和一个字符组成的特殊序列在以下列出：

+ \number：匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 (.+) \1 匹配 'the the' 或者 '55 55', 但不会匹配 'thethe' (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 number 的第一个数位是0，或者number是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 '[' 和 ']' 字符集合内，任何数字转义都被看作是字符。
+ \A：只匹配字符串开始。
+ \b：匹配空字符串，但只在单词开始或结尾的位置。一个单词被定义为一个单词字符的序列。注意，通常 \b 定义为 \w 和 \W 字符之间，或者 \w 和字符串开始/结尾的边界，意思就是 r'\bfoo\b' 匹配 'foo', 'foo.', '(foo)', 'bar foo baz' 但不匹配 'foobar' 或者'foo3'。
+ \B：匹配空字符串，但不能在词的开头或者结尾。意思就是 r'py\B' 匹配 'python', 'py3', 'py2', 但不匹配 'py', 'py.', 或者 'py!'. \B 是 \b 的取非，所以Unicode样式的词语是由Unicode字母，数字或下划线构成的，虽然可以用 ASCII 标志来改变。如果使用了 LOCALE 标志，则词的边界由当前语言区域设置。
+ \d：对于 Unicode (str) 样式，匹配任何Unicode十进制数（就是在Unicode字符目录[Nd]里的字符）。这包括了[0-9] ，和很多其他的数字字符。如果设置了 ASCII 标志，就只匹配 [0-9]。对于8位(bytes)样式，匹配任何十进制数，就是 [0-9]。
+ \D：匹配任何非十进制数字的字符。就是\d取非。如果设置了ASCII标志，就相当于 [^0-9]。
+ \s：对于Unicode (str)样式，匹配任何Unicode空白字符（包括[ \t\n\r\f\v] ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 ASCII 被设置，就只匹配[ \t\n\r\f\v]。对于8位(bytes)样式，匹配ASCII中的空白字符，就是 [ \t\n\r\f\v]。
+ \S：匹配任何非空白字符。就是\s取非。如果设置了ASCII标志，就相当于[^ \t\n\r\f\v]。
+ \w：对于 Unicode (str)样式，匹配Unicode词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 ASCII 标志，就只匹配 [a-zA-Z0-9_]。对于8位(bytes)样式，匹配ASCII字符中的数字和字母和下划线，就是 [a-zA-Z0-9_]。如果设置了 LOCALE 标记，就匹配当前语言区域的数字和字母和下划线。
+ \W：匹配任何非词语字符。是 \w 取非。如果设置了 ASCII 标记，就相当于 [^a-zA-Z0-9_]。如果设置了 LOCALE 标志，就匹配当前语言区域的非词语字符。
+ \Z：只匹配字符串尾。

模块内容：

+ re.compile(pattern, flags=0)：将正则表达式的样式编译为一个正则表达式对象（正则对象），可以用于匹配，通过这个对象的方法 match(), search() 以及其他如下描述。如果需要多次使用这个正则表达式的话，使用 re.compile() 和保存这个正则对象以便复用，可以让程序更加高效，因为通过 re.compile() 编译后的样式和模块级的函数会被缓存。
+ re.A、re.ASCII：让 \w, \W, \b, \B, \d, \D, \s 和 \S 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 (?a)。
+ re.DEBUG：显示编译时的debug信息，没有内联标记。
+ re.I、re.IGNORECASE：进行忽略大小写匹配；表达式如 [A-Z] 也会匹配小写字符。Unicode匹配（比如 Ü 匹配 ü）同样有用，除非设置了 re.ASCII 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 re.LOCALE 标记。这个相当于内联标记 (?i)。
+ re.L、re.LOCALE：由当前语言区域决定 \w, \W, \b, \B 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个"习惯”，而且只对8位字节有效。Unicode匹配在Python 3里默认启用，并可以处理不同语言。这个对应内联标记 (?L)。
+ re.M、re.MULTILINE：设置以后，样式字符 '^' 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 '$' 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。对应内联标记 (?m)。
+ re.S、re.DOTALL：让 '.'特殊字符匹配任何字符，包括换行符；如果没有这个标记，'.'就匹配除了换行符的其他任意字符。对应内联标记 (?s)。
+ re.X、re.VERBOSE：这个标记允许编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 *?, (?: or (?P<…> 分组之内。当一个行内有 # 不在字符集和转义序列，那么它之后的所有字符都是注释。对应内联标记(?x)。
+ re.search(pattern, string, flags=0)：扫描整个字符串找到匹配样式的第一个位置，并返回一个相应的匹配对象。如果没有匹配，就返回一个None；注意这和找到一个零长度匹配是不同的。
+ re.match(pattern, string, flags=0)：如果string开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的匹配对象。如果没有匹配，就返回None；注意它跟零长度匹配是不同的。注意，即便是MULTILINE多行模式，re.match() 也只匹配字符串的开始位置，而不匹配每行开始。
+ re.fullmatch(pattern, string, flags=0)：如果整个string匹配到正则表达式样式，就返回一个相应的匹配对象。否则就返回一个 None；注意这跟零长度匹配是不同的。
+ re.split(pattern, string, maxsplit=0, flags=0)：用 pattern 分开 string。如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 maxsplit非零，最多进行 maxsplit次分隔，剩下的字符全部返回到列表的最后一个元素。
+ re.findall(pattern, string, flags=0)：对 string 返回一个不重复的 pattern 的匹配列表，string 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里。
+ re.finditer(pattern, string, flags=0)：pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了匹配对象。string 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。
+ re.sub(pattern, repl, string, count=0, flags=0)：返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串。如果样式没有找到，则不加改变地返回 string。repl可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。也就是说，\n 会被转换为一个换行符，\r 会被转换为一个回车附，依此类推。未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。其他未知转义序列例如 \& 会保持原样。向后引用像是 \6 会用样式中第 6 组所匹配到的子字符串来替换。如果 repl 是一个函数，那它会对每个非重复的 pattern 的情况调用。这个函数只能有一个匹配对象参数，并返回一个替换后的字符串。
+ re.subn(pattern, repl, string, count=0, flags=0)：行为与 sub() 相同，但是返回一个元组(字符串, 替换次数)。
+ re.escape(pattern)：转义 pattern 中的特殊字符。如果想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。这个函数不能用在 sub() 和 subn() 的替换字符串里，只有反斜杠应该被转义。
+ re.purge()：清除正则表达式缓存。
+ exception re.error(msg, pattern=None, pos=None)：raise一个例外。当传递到函数的字符串不是一个有效正则表达式的时候（比如，包含一个不匹配的括号）或者其他错误在编译时或匹配时产生。如果字符串不包含样式匹配，是不会被视为错误的。

编译后的正则表达式对象支持一下方法和属性：

+ Pattern.search(string[, pos[, endpos]])：扫描整个string寻找第一个匹配的位置，并返回一个相应的匹配对象。如果没有匹配，就返回None；注意它和零长度匹配是不同的。
+ Pattern.match(string[, pos[, endpos]])：如果string的开始位置能够找到这个正则样式的任意个匹配，就返回一个相应的匹配对象。如果不匹配，就返回 None；注意它与零长度匹配是不同的。
+ Pattern.fullmatch(string[, pos[, endpos]])：如果整个string 匹配这个正则表达式，就返回一个相应的匹配对象。否则就返回 None；注意跟零长度匹配是不同的。
+ Pattern.split(string, maxsplit=0)：等价于 split() 函数，使用了编译后的样式。
+ Pattern.findall(string[, pos[, endpos]])：类似函数findall()，使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()。
+ Pattern.finditer(string[, pos[, endpos]])：类似函数finiter() 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()。
+ Pattern.sub(repl, string, count=0)：等价于 sub() 函数，使用了编译后的样式。
+ Pattern.subn(repl, string, count=0)：等价于 subn() 函数，使用了编译后的样式。
+ Pattern.flags：正则匹配标记。这是可以传递给 compile() 的参数，任何 (?…) 内联标记，隐性标记比如 UNICODE 的结合。
+ Pattern.groups：捕获组合的数量。
+ Pattern.groupindex：映射由`(?P<id>)`定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。
+ Pattern.pattern：编译对象的原始样式字符串。

匹配对象总是有一个布尔值 True。如果没有匹配的话 match() 和 search()返回None所以可以简单的用 if 语句来判断是否匹配。匹配对象支持以下方法和属性：

+ Match.expand(template)：对 template 进行反斜杠转义替换并且返回，就像 sub() 方法中一样。转义如同 \n 被转换成合适的字符，数字引用(\1, \2)和命名组合`(\g<1>, \g<name>)`替换为相应组合的内容。
+ Match.group([group1, ...])：返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，一个 IndexError 索引错误就 raise。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。
+ Match.__getitem__(g)：这个等价于 m.group(g)。这允许更方便的引用一个匹配。
+ Match.groups(default=None)：返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。default 参数用于不参与匹配的情况，默认为 None。
+ Match.groupdict(default=None)：返回一个字典，包含了所有的命名子组。key就是组名。default参数用于不参与匹配的组合；默认为 None。
+ Match.start([group])、Match.end([group])：返回 group 匹配到的字串的开始和结束标号。group 默认为0（意思是整个匹配的子串）。如果 group 存在，但未产生匹配，就返回 -1。
+ Match.span([group])：对于一个匹配 m，返回一个二元组(m.start(group), m.end(group)) 。注意如果 group 没有在这个匹配中，就返回 (-1, -1) 。group 默认为0，就是整个匹配。
+ Match.pos：pos的值，会传递给 search() 或 match() 的方法 a 正则对象。这个是正则引擎开始在字符串搜索一个匹配的索引位置。
+ Match.endpos：endpos的值，会传递给 search() 或 match() 的方法 a 正则对象。这个是正则引擎停止在字符串搜索一个匹配的索引位置。
+ Match.lastindex：捕获组的最后一个匹配的整数索引值，或者None如果没有匹配产生的话。比如，对于字符串'ab'，表达式 (a)b, ((a)(b)), 和 ((ab)) 将得到 lastindex == 1，而 (a)(b) 会得到 lastindex == 2。
+ Match.lastgroup：最后一个匹配的命名组名字，或者 None 如果没有产生匹配的话。
+ Match.re：返回产生这个实例的正则对象，这个实例是由正则对象的match() 或 search() 方法产生的。
+ Match.string：传递到 match() 或 search() 的字符串。
