# 函数式编程相关

## itertools

itertools用于高效循环的迭代函数集合。包含一些使用功能。

无穷迭代器:

迭代器|示例
--|--
count(start, [step])|count(10) --> 10 11 12 13 14 ...
cycle(p)|cycle('ABCD') --> A B C D A B C D ...
repeat(elem [,n])|repeat(10, 3) --> 10 10 10

根据最短输入序列长度停止的迭代器：

迭代器|示例
--|--
accumulate(p [,func])|accumulate([1,2,3,4,5]) --> 1 3 6 10 15
chain(p, q, ...)|chain('ABC', 'DEF') --> A B C D E F
chain.from_iterable(iterable)|chain.from_iterable(['ABC', 'DEF']) --> A B C D E F
compress(data, selectors)|compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F
dropwhile(pred, seq)|dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1
filterfalse(pred, seq)|filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8
groupby(iterable[, key])|根据key(v)值分组的迭代器
islice(seq, [start,] stop [, step])|islice('ABCDEFG', 2, None) --> C D E F G
starmap(func, seq)|starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000
takewhile(pred, seq)|takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4
tee(it, n)|it1, it2, ... itn将一个迭代器拆分为n个迭代器
zip_longest(p, q, ...)|zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

排列组合迭代器：

迭代器|结果
--|--
product(p, q, ... [repeat=1])|笛卡尔积，相当于嵌套的for循环
permutations(p[, r])|长度r元组，所有可能的排列，无重复元素
combinations(p, r)|长度r元组，有序，无重复元素
combinations_with_replacement(p, r)|长度r元组，有序，元素可重复

示例：

+ product('ABCD', repeat=2)：AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD
+ permutations('ABCD', 2)：AB AC AD BA BC BD CA CB CD DA DB DC
+ combinations('ABCD', 2)：AB AC AD BC BD CD
+ combinations_with_replacement('ABCD', 2)：AA AB AC AD BB BC BD CC CD DD

## functools

functools，用于高阶函数：指参数或（和）返回值为其他函数的函数。通常来说，此模块的功能适用于所有可调用对象。该模块定义了以下函数：

+ functools.cmp_to_key(func)：将(旧式的)比较函数转换为新式的key function。在类似于sorted()， min()， max()， heapq.nlargest()， heapq.nsmallest()，itertools.groupby()等函数的 key 参数中使用。此函数主要用作将 Python 2程序转换至新版的转换工具，以保持对比较函数的兼容。比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，并返回另一个用以排序的值的可调用对象。
+ @functools.lru_cache(maxsize=128, typed=False)：一个提供缓存功能的装饰器，包装一个函数，缓存其maxsize组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或高I/O函数的调用时间。由于使用了字典存储缓存，所以被修饰的函数的固定参数和关键字参数必须是可哈希的。不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2)和f(b=2, a=1)因其参数顺序不同，可能会被缓存两次。如果 maxsize 设置为None，LRU功能将被禁用且缓存数量无上限。maxsize设置为2的幂时可获得最佳性能。如果 typed设置为true，不同类型的函数参数将被分别缓存。例如，f(3)和f(3.0)将被视为不同而分别缓存。该装饰器也提供了一个用于清理/使缓存失效的函数 cache_clear()。
+ @functools.total_ordering：类修饰器，某个类如果定义了__lt__、le、gt、__ge__这些方法中的至少一个，使用该装饰器，则会自动的把其他几个比较函数也实现在该类中。注意：虽然这个装饰器可以很容易地创建表现良好的完全有序的类型，但它确实以较慢的执行成本和更复杂的派生比较方法的堆栈跟踪为代价。如果性能基准测试表明这是给定应用程序的瓶颈，那么实现所有六种丰富的比较方法可能会提供简单的速度提升。
+ functools.partial(func, *args, **keywords)：返回一个新的partial对象。通过包装手法，允许"重新定义"函数签名。用一些默认参数包装一个可调用对象,返回结果是可调用对象，并且可以像原始对象一样对待冻结部分函数位置函数或关键字参数，以简化函数，使其可以用更少更灵活的函数参数调用。
+ class functools.partialmethod(func, *args, **keywords)：返回一个新的partialmethod描述符，其行为类似于partial它被设计为用作方法定义而不是可直接调用。func必须是描述符或可调用的（与正常函数一样，对象都作为描述符处理）。
+ functools.reduce(function, iterable[, initializer])：应用函数的两个参数来累计序列，从左至右这样的顺序，最后返回单个值。
+ @functools.singledispatch：将函数转换为单调度泛型函数。要向函数添加重载实现，请使用@fun.register()泛型函数的装饰器。
+ functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)：默认partial对象没有__name__和__doc__, 这种情况下，对于装饰器函数非常难以debug。所以使用update_wrapper()，将他们从原始对象拷贝或加入到现有partial对象。它可以把原始函数的__name__、module、__doc__和 __dict__都复制到封装函数中去(模块级别常量WRAPPER_ASSIGNMENTS, WRAPPER_UPDATES)。这个函数主要用在装饰器函数中，装饰器返回函数反射得到的是包装函数的函数定义而不是原始函数定义。
+ @functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)：这是一个便利函数，调用函数装饰器partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)的简写。

## operator--标准运算符替代函数

operator模块提供了一套与Python的内置运算符对应的高效率函数。例如，operator.add(x, y)与表达式 x+y 相同。许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。
