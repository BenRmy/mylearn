# 文件和目录访问模块

## pathlib--面向对象的文件系统模块

该模块提供表示文件系统路径的类，其语义适用于不同的操作系统。路径类被分为提供纯计算操作而没有I/O操作的纯路径，以及从纯路径继承而来但提供I/O操作的具体路径。对于底层的路径字符串操作，也可以使用 os.path 模块。purepath纯路径可用于：

+ 在Unix设备上操作Windows路径（或者相反）时，不应实例化一个WindowsPath，但可以实例化为PureWindowsPath。
+ 只想操作路径但不想实际访问操作系统。

基本操作：

```python
from pathlib import Path

# 传入目录路径，实例化
dir_path = Path('.')
# 列出目录下文件夹
print([x for x in dir_path.iterdir() if x.is_dir()])
# 列出目录树下(包括子目录)所有 Python 源代码文件
print(list(dir_path.glob('**/*.py')))
# 在目录树中移动(unix)
new_path = dir_path / 'python'
# 路径对象的属性
print(new_path.exists())
# 打开一个文件(unix)
file_path = Path('.README.md')
with file_path.open() as f:
    print(f.read())
```

纯路径（其操作不涉及系统调用）：

+ class pathlib.PurePath(*pathsegments)：一个通用的类，代表当前系统的路径风格（实例化为PurePosixPath或者PureWindowsPath）。当pathsegments为空的时候，假定为当前目录；有多个字符串时，则是用'/'.join()来连接。但是，在 Windows 路径中，改变本地根目录并不会丢弃之前盘符的设置。
+ class pathlib.PurePosixPath(*pathsegments)：PurePath 的一个子类，路径风格不同于 Windows 文件系统，其是从根目录开始。
+ class pathlib.PureWindowsPath(*pathsegments)：PurePath的一个子类，路径风格为 Windows 文件系统路径，包含盘符。

类属性和方法：

+ PurePath.drive：表示驱动器盘符或命名的字符串（如果存在）
+ PurePath.root：表示（本地或全局）根的字符串（如果存在）
+ PurePath.anchor：驱动器和根的联合
+ PurePath.parents：不可变序列，提供对路径逻辑祖先的访问
+ PurePath.parent：路径的逻辑父路径
+ PurePath.name：表示最后路径组件的字符串，排除了驱动器与根目录（如果存在）
+ PurePath.suffix：最后组件的文件扩展名（如果存在）
+ PurePath.suffixes：路径的文件扩展名列表
+ PurePath.stem：路径最后组件，除去后缀
+ PurePath.as_posix()：返回使用正斜杠（/）的路径字符串
+ PurePath.as_uri()：将路径表示为file URL。如果不是绝对路径，抛出ValueError
+ PurePath.is_absolute()：返回此路径是否为绝对路径。如果路径同时拥有驱动器符与根路径（如果风格允许）则将被认作绝对路径
+ PurePath.is_reserved()：在PureWindowsPath中，如果路径是被Windows保留的则返回True，否则False。在PurePosixPath，总是返回False。当保留路径上的文件系统被调用，则可能出现玄学失败或者意料之外的效应。
+ PurePath.joinpath(*other)：调用此方法等同于将每个other参数中的项目连接在一起
+ PurePath.match(pattern)：将此路径与提供的通配符风格的模式匹配。如果匹配成功则返回True，否则返回False。如果pattern是相对的，则路径可以是相对路径或绝对路径，并且匹配是从右侧完成的
+ PurePath.relative_to(*other)：计算此路径相对other表示路径的版本。如果不可计算，则抛出 ValueError
+ PurePath.with_name(name)：返回一个新的路径并修改name。如果原本路径没有name，ValueError被抛出
+ PurePath.with_suffix(suffix)：返回一个新的路径并修改suffix。如果原本的路径没有后缀，新的suffix则被追加以代替。如果suffix是空字符串，则原本的后缀被移除

Path类方法：

+ classmethod Path.cwd()：返回一个新的表示当前目录的路径对象（和os.getcwd()返回的相同）
+ classmethod Path.home()：返回一个表示当前用户家目录的新路径对象（和os.path.expanduser()构造含 ~ 路径返回的相同）
+ Path.stat()：返回此路径的信息，类似于os.stat()。结果在每次调用此方法时都重新产生
+ Path.chmod(mode)：改变文件的模式和权限，和 os.chmod() 一样
+ Path.exists()：此路径是否指向一个已存在的文件或目录
+ Path.expanduser()：返回展开了包含 ~ 和 ~user 的构造，就和os.path.expanduser()一样
+ Path.glob(pattern)：解析相对于此路径的通配符pattern，产生所有匹配的文件。"**" 模式表示此目录以及所有子目录，换句话说，它启用递归通配
+ Path.group()：返回拥有此文件的用户组。如果文件的 GID 无法在系统数据库中找到，将抛出KeyError
+ Path.is_dir()：如果路径指向一个目录（或者一个指向目录的符号链接）则返回 True，如果指向其他类型的文件则返回 False。当路径不存在或者是一个破损的符号链接时也会返回 False；其他错误（例如权限错误）将被传播
+ Path.is_file()：如果路径指向一个正常的文件（或者一个指向正常文件的符号链接）则返回 True，如果指向其他类型的文件则返回 False。当路径不存在或者是一个破损的符号链接时也会返回 False；其他错误（例如权限错误）将被传播。
+ Path.is_mount()：如果路径是一个挂载点。在POSIX系统，此函数检查path的父级是否处于一个和path不同的设备中，这能检测所有 Unix 以及 POSIX 变种上的挂载点。 Windows上未实现。
+ Path.is_symlink()：如果路径指向符号链接则返回True，否则False。如果路径不存在也返回 False；其他错误（例如权限错误）被传播。
+ Path.is_socket()：如果路径指向一个 Unix socket 文件（或者指向 Unix socket 文件的符号链接）则返回True，如果指向其他类型的文件则返回False。当路径不存在或者是一个破损的符号链接时也会返回 False；其他错误（例如权限错误）被传播
+ Path.is_fifo()：如果路径指向一个先进先出存储（或者指向先进先出存储的符号链接）则返回 True，指向其他类型的文件则返回 False。当路径不存在或者是一个破损的符号链接时也会返回 False；其他错误（例如权限错误）被传播
+ Path.is_block_device()：如果文件指向一个块设备（或者指向块设备的符号链接）则返回 True，指向其他类型的文件则返回 False。当路径不存在或者是一个破损的符号链接时也会返回 False；其他错误（例如权限错误）被传播
+ Path.is_char_device()：如果路径指向一个字符设备（或指向字符设备的符号链接）则返回 True，指向其他类型的文件则返回 False。当路径不存在或者是一个破损的符号链接时也会返回 False；其他错误（例如权限错误）被传播
+ Path.iterdir()：当路径指向一个目录时，产生该路径下的对象的路径的迭代器
+ Path.lchmod(mode)：就像 Path.chmod() 但是如果路径指向符号链接则是修改符号链接的模式，而不是修改符号链接的目标
+ Path.lstat()：就和 Path.stat()一样，但是如果路径指向符号链接，则是返回符号链接而不是目标的信息
+ Path.mkdir(mode=0o777, parents=False, exist_ok=False)：新建给定路径的目录。如果给出了mode，它将与当前进程的umask值合并来决定文件模式和访问标志。如果路径已经存在，则抛出 FileExistsError。
+ Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)：打开路径指向的文件，就像内置的 open() 函数所做的一样
+ Path.owner()：返回拥有此文件的用户名。如果文件的 UID 无法在系统数据库中找到，则抛出 KeyError
+ Path.read_bytes()：以字节对象的形式返回路径指向的文件的二进制内容
+ Path.read_text(encoding=None, errors=None)：以字符串形式返回路径指向的文件的解码后文本内容
+ Path.rename(target)：使用给定的target将文件重命名。在 Unix上，如果target已经存在并且为文件，则只要用户拥有权限，其将被静默地被覆盖。target可以是一个字符串或者另一个路径对象
+ Path.replace(target)：使用给定的target重命名文件或目录。如果target指向现存的文件或目录，则将被无条件覆盖
+ Path.resolve(strict=False)：将路径绝对化，解析任何符号链接，返回新的路径对象
+ Path.rglob(pattern)：就像调用 Path.glob时在给定的相对pattern前面添加了"**/`()"
+ Path.rmdir()：移除此目录。此目录必须为空的
+ Path.samefile(other_path)：返回此目录是否指向与可能是字符串或者另一个路径对象的other_path相同的文件。语义类似于os.path.samefile()与os.path.samestat()。如果两者都以同一原因无法访问，则抛出OSError
+ Path.symlink_to(target, target_is_directory=False)：将此路径创建为指向 target的符号链接。在Windows下，如果链接的目标是一个目录则target_is_directory必须为true（默认为False）。在 POSIX 下，target_is_directory 的值将被忽略
+ Path.touch(mode=0o666, exist_ok=True)：将给定的路径创建为文件。如果给出了 mode它将与当前进程的umask值合并以确定文件的模式和访问标志。如果文件已经存在，则当 exist_ok 为 true 则函数仍会成功（并且将它的修改事件更新为当前事件），否则抛出 FileExistsError
+ Path.unlink()：移除此文件或符号链接。如果路径指向目录，则用 Path.rmdir() 代替
+ Path.write_bytes(data)：将文件以二进制模式打开，写入data并关闭
+ Path.write_text(data, encoding=None, errors=None)：将文件以文本模式打开，写入data并关闭

## fileinput--迭代多个输入流中的行

该模块实现了一个辅助类和函数，可以通过标准输入或文件列表快速编写循环。如果只是想读或写一个文件，请使用open()。典型用途是：

```python
import fileinput

for line in fileinput.input():
    process(line)

with fileinput.input('1.txt') as f:
    for line in f:
        process(line)
```

全局状态：

+ fileinput.filename()：返回当前正在读取的文件的名称。在读取第一行之前，返回None
+ fileinput.fileno()：返回当前文件的文件描述符（整数）。如果没有打开文件（在第一行之前和文件之间），则返回-1
+ fileinput.lineno()：返回刚读过的行的累计行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该行的行号
+ fileinput.filelineno()：返回当前文件中的行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该文件中该行的行号
+ fileinput.isfirstline()：如果刚刚读取的行是其文件的第一行，则返回true，否则返回false
+ fileinput.isstdin()：如果读取了最后一行sys.stdin，则返回true，否则返回false
+ fileinput.nextfile()：关闭当前文件，以便下一次迭代将读取下一个文件的第一行（如果有的话）; 未从文件中读取的行将不计入累计行数。直到读取下一个文件的第一行之后才会更改文件名。在读取第一行之前，此功能无效; 它不能用于跳过第一个文件。读取完最后一个文件的最后一行后，此功能无效
+ fileinput.close()：关闭序列

## shutil--高级文件操作

该模块对文件和文件集合提供了许多高级操作。特别是提供了支持文件复制和删除的功能。注意：即使是更高级别的文件复制功能shutil.copy()，shutil.copy2()也无法复制所有文件元数据。在POSIX平台上，这意味着文件所有者和组以及ACL都会丢失。在Mac OS上，不使用资源分支和其他元数据。这意味着资源将丢失，文件类型和创建者代码将不正确。在Windows上，不会复制文件所有者，ACL和备用数据流。

主要功能：

+ shutil.copyfileobj(fsrc, fdst[, length])：将文件fsrc的数据覆盖copy给文件fdst（需要先打开文件）。
+ shutil.copyfile(src, dst, *, follow_symlinks=True)：不用打开文件，直接用文件名进行copy覆盖。
+ shutil.copymode(src, dst, *, follow_symlinks=True)：拷贝权限，内容组，用户。
+ shutil.copystat(src, dst, *, follow_symlinks=True)：只拷贝权限。
+ shutil.copy(src, dst, *, follow_symlinks=True)：文件和权限都进行copy。
+ shutil.copy2(src, dst, *, follow_symlinks=True)：拷贝文件和状态信息
+ shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)：递归copy多个目录到指定目录下
+ shutil.rmtree(path, ignore_errors=False, onerror=None)：递归删除目录下的目录及文件
+ shutil.move(src, dst, copy_function=copy2)：递归移动一个文件
+ shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])：压缩，打包文件
