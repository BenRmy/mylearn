# 数据类型或数据结构

## collections

这个模块实现了特定目标的容器，以提供Python标准内建容器dict , list , set和 tuple的替代选择。内容：

名称|说明
--|--
namedtuple()|创建命名元组子类的工厂函数
deque|类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)
ChainMap|类似字典(dict)的容器类，将多个映射集合到一个视图里面
Counter|字典的子类，提供了可哈希对象的计数功能
OrderedDict|字典的子类，保存了他们被添加的顺序
defaultdict|字典的子类，提供了一个工厂函数，为字典查询提供一个默认值
UserDict|封装了字典对象，简化了字典子类化
UserList|封装了列表对象，简化了列表子类化
UserString|封装了列表对象，简化了字符串子类化

class collections.ChainMap(*maps)：一个 ChainMap 类是为了将多个映射快速的链接到一起，这样它们就可以作为一个单元处理。它通常比创建一个新字典和多次调用update()要快很多。一个 ChainMap通过引用合并底层映射。所以，如果一个底层映射更新了，这些更改会反映到ChainMap。

```python
baseline = {'music': 'bach', 'art': 'rembrandt'}
adjustments = {'art': 'van gogh', 'opera': 'carmen'}
list(ChainMap(adjustments, baseline))
```

class collections.Counter([iterable-or-mapping])：提供快速和方便的计数功能的一个计数器工具。一个Counter是一个dict的子类，用于计数可哈希对象。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。

class collections.deque([iterable[, maxlen]])：返回一个新的双向队列对象，从左到右初始化(用方法 append())，从iterable（迭代对象) 数据创建。如果iterable没有指定，新队列为空。支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。虽然 list 对象也支持类似操作，不过这里优化了定长操作和 pop(0) 和 insert(0, v) 的开销。它们引起 O(n) 内存移动的操作，改变底层数据表达的大小和位置。如果 maxlen 没有指定或者是 None，deques可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。

class collections.defaultdict([default_factory[, ...]])：返回一个新的类似字典的对象。defaultdict是内置 dict 类的子类。它重载了一个方法并添加了一个可写的实例变量。其余的功能与dict类相同。第一个参数 default_factory 提供了一个初始值。它默认为 None。所有的其他参数都等同与 dict 构建器中的参数对待，包括关键词参数。

```python
s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
d = defaultdict(list)
for k, v in s:
    d[k].append(v)
print(sorted(d.items()))
```

collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)：返回一个新的元组子类，名为typename。这个新的子类用于创建类元组的对象，可以通过field_names字段名来获取属性值，同样也可以通过索引和迭代获取值。子类实例同样有文档字符串（类名和字段名）和一个有用的__repr__()方法，以 name=value 格式列明了元组内容。字段名可以是一个字符串序列。也可以是一个纯字符串，用空白或逗号分隔开元素名，比如 'x y' 或者'x, y'。如果 rename为False，无效字段名会自动转换成相应的位置名。defaults可以为None或者是一个默认值的iterable，其是提供字段名的默认值。如果 module 值有定义，命名元组的__module__属性值就被设置。因为一个命名元组是一个正常的Python类，它可以很容易的通过子类更改功能。由于命名元组实例没有字典，所以它们要更轻量，并且占用更小内存。

class collections.OrderedDict([items])：返回一个dict子类的实例，它具有专门用于重新排列字典顺序的方法。相对于通常的映射方法，有序字典还通过reversed()提供了逆序迭代的支持。

class collections.UserDict([initialdata])：模拟一个字典类。这个实例的内容保存为一个正常字典，可以通过UserDict实例的data属性存取。如果提供了initialdata值，data就被初始化为它的内容。注意一个 initialdata 的引用不会被保留作为其他用途。UserDict类是用作字典对象的外包装。对这个类的需求已部分由直接创建 dict 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字典可以作为属性来访问。

class collections.UserList([list])：模拟一个列表。这个实例的内容被保存为一个正常列表，通过 UserList的data属性存取。实例内容被初始化为一个list的copy，默认为 [] 空列表。list可以是迭代对象，比如一个Python列表，或者一个 UserList 对象。这个类封装了列表对象。它是一个有用的基础类，对于想自定义的类似列表的类，可以继承和覆盖现有的方法，也可以添加新的方法。这样可以对列表添加新的行为。对这个类的需求已部分由直接创建 list 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的列表可以作为属性来访问。

class collections.UserString(seq)：模拟一个字符串对象。这个实例对象的内容保存为一个正常字符串，通过 UserString的data属性存取。实例内容初始化设置为 seq的copy。seq参数可以是任何可通过内建 str() 函数转换为字符串的对象。UserString 类是用作字符串对象的外包装。对这个类的需求已部分由直接创建 str 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字符串可以作为属性来访问。

## heapq--堆队列算法，也称为优先队列算法

堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点。它使用了数组来实现：从零开始计数，对于所有的 k，都有heap[k] <= heap[2*k+1]和heap[k] <= heap[2*k+2]。为了便于比较，不存在的元素被认为是无限大。堆最有趣的特性在于最小的元素总是在根结点：heap[0]。可以将堆看作原生的Python list，其中list[0]表示最小的元素，同时list.sort() 维护了列表的顺序！

其中定义的函数：

+ heapq.heappush(heap, item)：将item的值加入heap中，保持堆的不变性。
+ heapq.heappop(heap)：弹出并返回heap的最小的元素，保持堆的不变性。如果堆为空，抛出 IndexError。若使用heap[0]，可以只访问最小的元素而不弹出它。
+ heapq.heappushpop(heap, item)：将item放入堆中，然后弹出并返回heap的最小元素。该组合操作比先调用heappush()再调用heappop()运行起来更有效率。
+ heapq.heapify(x)：将list x 转换成堆，原地，线性时间内。
+ heapq.heapreplace(heap, item)：弹出并返回堆中的最小项，并同时推送新项。堆大小不会改变。如果堆为空，IndexError则引发。
+ heapq.merge(*iterables, key=None, reverse=False)：将多个已排序的输入合并为单个排序的输出（例如，合并来自多个日志文件的带时间戳的条目）。返回一个iterable，不会同时将数据全部拉入内存，并假设每个输入流已经排序（从最小到最大）。key指定一个参数的键函数，用于从每个输入元素中提取比较键。
+ heapq.nlargest(n, iterable, key=None)：返回一个列表，其中包含iterable定义的数据集中的n个最大元素。key指定一个参数的函数，该函数用于从iterable中的每个元素中提取比较键。
+ heapq.nsmallest(n, iterable, key=None)：返回一个列表，其中包含iterable定义的数据集中的n个最小元素。key指定一个参数的函数，该函数用于从iterable中的每个元素中提取比较键。

## copy--浅层 (shallow) 和深层 (deep) 复制

Python 中赋值语句不复制对象，而是在目标和对象之间创建绑定 (bindings) 关系。对于自身可变或者包含可变项的集合对象，开发者有时会需要生成其副本用于改变操作，进而避免改变原对象。浅层复制和深层复制之间的区别仅与复合对象 (即包含其他对象的对象，如列表或类的实例) 相关：

+ 一个浅复制会构造一个新的复合对象，然后将原对象中找到的引用插入其中
+ 一个深复制会构造一个新的复合对象，然后递归地将原始对象中所找到的对象的副本插入

方法：

+ copy.copy(x)：返回 x 的浅层复制
+ copy.deepcopy(x[, memo])：返回 x 的深层复制
+ exception copy.error：针对模块特定错误引发

## pprint--数据美化输出

该pprint模块提供了一种“漂亮打印”任意Python数据结构的功能，该形式可用作解释器的输入。如果格式化结构包含非基本Python类型的对象，则表示可能无法加载。如果包含诸如文件，套接字或类之类的对象，以及许多其他不能表示为Python文字的对象，则可能出现这种情况。

class pprint.PrettyPrinter(indent=1, width=80, depth=None, stream=None, *, compact=False)：构造一个PrettyPrinter实例。可以使用stream关键字设置输出流;流对象上使用的唯一方法是文件协议的write()方法。如果没有指定，则PrettyPrinter采用sys.stdout。indent为每个递归级别添加的缩进量由缩进指定; 默认值为1。可打印的级别数由depth深度控制; 如果要打印的数据结构太深，则下一个包含的级别将替换为...。默认情况下，对要格式化的对象的深度没有约束。使用width参数约束所需的输出宽度; 默认值为80个字符。如果compact为false（默认值），则长序列中的每个项目将在单独的行上进行格式化。如果compact为true，则将在每个输出行上格式化适合宽度的项目。

几个快捷方法：

+ pprint.pformat(object, indent=1, width=80, depth=None, *, compact=False)：将对象的格式化表示形式以字符串返回
+ pprint.pprint(object, stream=None, indent=1, width=80, depth=None, *, compact=False)：在流上打印对象的格式化表示，后面跟换行符
+ pprint.isreadable(object)：确定对象的格式化表示是否“可读”，或者可以使用eval()重构值。递归对象总是返回False
+ pprint.isrecursive(object)：确定对象是否需要递归表示
+ pprint.saferepr(object)：返回对象的字符串表示形式，以防止递归数据结构
