# 日志记录及处理

## logging--Python的日志记录工具

logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等。

基本使用示例（控制台输出）:

```python
import logging

logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

logger.info('start this!')
logger.debug('this is debug!')
logger.warning('no.it is a waring!')
logger.error('bad,it is error!')
logger.info('ok,it is end!')
```

logging中可以选择很多消息级别，如debug、info、warning、error以及critical。通过赋予logger或者handler不同的级别，开发者就可以只输出错误信息到特定的记录文件，或者在调试时只记录调试信息。
注：当消息级别设置为INFO时，debug消息是不输出的。

logging.basicConfig函数各参数含义：

+ filename：指定日志文件名
+ filemode：和file函数意义相同，指定日志文件的打开模式，'w'或者'a'
+ format：指定输出的格式和内容
+ datefmt：指定时间格式，同time.strftime()
+ level：设置日志级别，默认为logging.WARNNING
+ stream：指定将日志的输出流，可以指定输出到sys.stderr，sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略

format参数的值：

+ %(levelno)s：打印日志级别的数值
+ %(levelname)s：打印日志级别的名称
+ %(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]
+ %(filename)s：打印当前执行程序名
+ %(funcName)s：打印日志的当前函数
+ %(lineno)d：打印日志的当前行号
+ %(asctime)s：打印日志的时间
+ %(thread)d：打印线程ID
+ %(threadName)s：打印线程名称
+ %(process)d：打印进程ID
+ %(message)s：打印日志信息

将日志写入到文件示例：设置logging，创建一个FileHandler，并对输出消息的格式进行设置，将其添加到logger，然后将日志写入到指定的文件中。

```python
import logging

logger = logging.getLogger(__name__)
logger.setLevel(level=logging.INFO)

handler = logging.FileHandler(filename='1.txt')
handler.setLevel(logging.INFO)
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)

logger.addHandler(handler)

logger.info('start this!')
logger.debug('this is debug!')
logger.warning('no.it is a waring!')
logger.error('bad,it is error!')
logger.info('ok,it is end!')
```

将日志写入到文件并在控制台打印示例：

```python
import logging

logger = logging.getLogger(__name__)
logger.setLevel(level=logging.INFO)

handler = logging.FileHandler(filename='1.txt')
handler.setLevel(logging.INFO)
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)

console = logging.StreamHandler()
console.setLevel(logging.INFO)
console.setFormatter(formatter)

logger.addHandler(handler)
logger.addHandler(console)

logger.info('start this!')
logger.debug('this is debug!')
logger.warning('no.it is a waring!')
logger.error('bad,it is error!')
logger.info('ok,it is end!')
```

logging有一个日志处理的主对象，其他处理方式都是通过addHandler添加进去，logging中包含的handler主要有如下几种：

+ StreamHandler：logging.StreamHandler。日志输出到流，可以是sys.stderr，sys.stdout或者文件
+ FileHandler：logging.FileHandler。日志输出到文件
+ BaseRotatingHandler：logging.handlers.BaseRotatingHandler。基本的日志回滚方式
+ RotatingHandler：logging.handlers.RotatingHandler。日志回滚方式，支持日志文件最大数量和日志文件回滚
+ TimeRotatingHandler：logging.handlers.TimeRotatingHandler。日志回滚方式，在一定时间区域内回滚日志文件
+ SocketHandler：logging.handlers.SocketHandler。远程输出日志到TCP/IP sockets
+ DatagramHandler：logging.handlers.DatagramHandler。远程输出日志到UDP sockets
+ SMTPHandler：logging.handlers.SMTPHandler。远程输出日志到邮件地址
+ SysLogHandler：logging.handlers.SysLogHandler。日志输出到syslog
+ NTEventLogHandler：logging.handlers.NTEventLogHandler。远程输出日志到Windows NT/2000/XP的事件日志
+ MemoryHandler：logging.handlers.MemoryHandler。日志输出到内存中的指定buffer
+ HTTPHandler：logging.handlers.HTTPHandler。通过"GET"或者"POST"远程输出到HTTP服务器

日志回滚示例：使用RotatingFileHandler

```python
from logging.handlers import RotatingFileHandler

logger = logging.getLogger(__name__)
logger.setLevel(level = logging.INFO)
#定义一个RotatingFileHandler，最多备份3个日志文件，每个日志文件最大1K
rHandler = RotatingFileHandler("log.txt",maxBytes = 1*1024,backupCount = 3)
rHandler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
rHandler.setFormatter(formatter)

logger.addHandler(rHandler)
```

消息等级：

+ FATAL：致命错误
+ CRITICAL：特别糟糕的事情，如内存耗尽、磁盘空间为空，一般很少使用
+ ERROR：发生错误时，如IO操作失败或者连接问题
+ WARNING：发生很重要的事件，但是并不是错误时，如用户登录密码错误
+ INFO：处理请求或者状态变化等日常事务
+ DEBUG：调试过程中使用DEBUG等级，如算法中每个循环的中间状态

捕获traceback示例：python中的traceback模块被用于跟踪异常返回信息，可以在logging中记录下traceback。  

```python
try:
    open("sklearn.txt","rb")
except (SystemExit,KeyboardInterrupt):
    raise
except Exception:
    logger.error("Faild to open sklearn.txt from logger.error",exc_info = True)
```

也可以使用logger.exception(msg,_args)，它等价于logger.error(msg,exc_info = True,_args)：

可以将logger.error("Faild to open sklearn.txt from logger.error",exc_info = True)替换为logger.exception("Failed to open sklearn.txt from logger.exception")

多模块使用logging：

+ 首先是在主文件中配置logger：logger = logging.getLogger("mainModule")  
+ 然后在子模块中直接引用名称，不需重新配置：sub_logger = logging.getLogger("mainModule.sub")  
+ 还有下级日志记录器可以继续添加：next_logger = logging.getLogger("mainModule.sub.app")

实际开发一个application时，首先可以通过logging配置文件编写好这个application所对应的配置，可以生成一个根logger，如'PythonAPP'，然后在主函数中通过fileConfig加载logging配置，接着在application的其他地方、不同的模块中，可以使用根logger的子logger，如'PythonAPP.Core'，'PythonAPP.Web'来进行log，而不需要反复的定义和配置各个模块的logger。

通过JSON或者YAML文件配置logging模块：尽管可以在Python代码中配置logging，但是这样并不够灵活，最好的方法是使用一个配置文件来配置。在Python 2.7及以后的版本中，可以从字典中加载logging配置，也就意味着可以通过JSON或者YAML文件加载日志的配置。
