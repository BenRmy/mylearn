# 内置函数

abs(x)：返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。

all(iterable)：如果iterable的所有元素为真（或迭代器为空），返回 True。

any(iterable)：如果iterable的任一元素为真则返回True。如果迭代器为空，返回False。

ascii(object)：类似repr()函数，返回一个对象可打印的字符串。但是repr()返回字符串中非 ASCII编码的字符时会使用 \x、\u 和 \U 来转义。生成的字符串和Python2的repr()返回的结果相似。

bin(x)：将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的Python表达式。如果x不是Python的int对象，那它需要定义__index__()方法返回一个整数。其也可以使用format()函数实现。

class bool([x])：返回一个布尔值，True或者False。x使用标准的真值测试过程来转换。如果x是假或者被省略，则返回False；其他情况返回True。bool类是int的子类，其他类不能继承自它。它只有 False和True两个实例。

breakpoint(*args, **kws)：此函数会在被调用时将程序陷入调试器中。具体来说，它调用sys.breakpointhook()，直接传递args和kws。默认情况下，sys.breakpointhook()调用pdb.set_trace()且没有参数。在这种情况下，它纯粹是一个便利函数，因此不必显式导入pdb且键入尽可能少的代码即可进入调试器。但是，sys.breakpointhook()可以设置为其他一些函数并被breakpoint()自动调用，以允许进入想用的调试器。

class bytearray([source[, encoding[, errors]]])：返回一个新的bytes数组。bytearray类是一个可变序列，包含范围为0<=x<256的整数。它有可变序列大部分常见的方法，同时有bytes类型的大部分方法。
可选形参 source 可以用不同的方式来初始化数组：

+ 如果是一个string，必须提供encoding参数（errors参数仍是可选的）；bytearray()会使用 str.encode() 方法来将 string 转变成 bytes。
+ 如果是一个 integer，会初始化大小为该数字的数组，并使用 null 字节填充。
+ 如果是一个符合 buffer 接口的对象，该对象的只读 buffer 会用来初始化字节数组。
+ 如果是一个 iterable 可迭代对象，它的元素的范围必须是 0 <= x < 256 的整数，它会被用作数组的初始内容。
+ 如果没有实参，则创建大小为 0 的数组。
  
class bytes([source[, encoding[, errors]]])：返回一个新的“bytes”对象，是一个不可变序列，包含范围为0<=x<256的整数。bytes是bytearray的不可变版本-它有其中不改变序列的方法和相同的索引、切片操作。因此，构造函数的实参和bytearray()相同。字节对象还可以用字面值创建。

callable(object)：如果实参object是可调用的，返回True，否则返回False。如果返回True，调用仍可能会失败；但如果返回假，则调用object肯定会失败。注意类是可调用的，如果实例的类有__call__()方法，则它是可调用。

chr(i)：返回Unicode码位为整数i的字符的字符串格式。例如，chr(97)返回字符串'a'，chr(8364)返回字符串'€'。这是ord()的逆函数。

@classmethod：把一个方法封装成类方法。类方法的调用可以在类上进行(例如C.f())也可以在实例上进行(例如C().f())。其所属类以外的类实例会被忽略。如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。

compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)：将source编译成代码或AST对象。代码对象可以被exec()或eval()执行。source可以是常规的字符串、字节字符串，或者AST对象。

class complex([real[, imag]])：返回值为real + imag*1j的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了imag，则默认值为零，构造函数会像int和float一样进行数值转换。如果两个实参都省略，则返回0j。

delattr(object, name)：setattr()相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如delattr(x, 'foobar') 等价于del x.foobar。

class dict(**kwarg)、class dict(mapping, **kwarg)、class dict(iterable, **kwarg)：创建一个新的字典。dict对象是一个字典类。

dir([object])：如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。默认的 dir() 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息。返回的列表按字母表排序。

divmod(a, b)：它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 (a // b, a % b) 一致。对于浮点数，结果是 (q, a % b) ，q 通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b 和 a 基本相等；如果 a % b 非零，它的符号和 b 一样，并且 0 <= abs(a % b) < abs(b)。

enumerate(iterable, start=0)：返回一个枚举对象。iterable必须是一个序列或iterator，或其他支持迭代的对象。enumerate()返回的迭代器的__next__()方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代iterable获得的值。

eval(expression, globals=None, locals=None)：实参是一个字符串，以及可选的globals和 locals。globals实参必须是一个字典，locals可以是任何映射对象。expression 参数会作为一个 Python 表达式（从技术上说是一个条件列表）被解析并求值，使用 globals 和 locals 字典作为全局和局部命名空间。如果 globals 字典存在且不包含以__builtins__为键的值，则会在解析expression之前插入以此为键的对内置模块builtins的字典的引用。这意味着 expression 通常具有对标准 builtins 模块的完全访问权限且受限的环境会被传播。如果省略 locals 字典则其默认值为 globals 字典。如果两个字典同时省略，表达式会在 eval() 被调用的环境中执行。返回值为表达式求值的结果。语法错误将作为异常被报告。这个函数也可以用来执行任何代码对象（如compile()创建的）。这种情况下，参数是代码对象，而不是字符串。如果编译该对象时的 mode 实参是'exec'那么 eval()返回值为None 。

exec(object[, globals[, locals]])：这个函数支持动态执行Python代码。object必须是字符串或者代码对象。如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。如果是代码对象，它将被直接执行。在任何情况下，被执行的代码都需要和文件输入一样是有效的。

filter(function, iterable)：用iterable中函数function返回真的那些元素，构建一个新的迭代器。iterable可以是一个序列，一个支持迭代的容器，或一个迭代器。如果function是None，则会假设它是一个身份函数，即iterable中所有返回假的元素会被移除。请注意，filter(function, iterable) 相当于一个生成器表达式，当function不是 None 的时候为 (item for item in iterable if function(item))；function 是 None 的时候为 (item for item in iterable if item)。

class float([x])：返回从数字或字符串 x 生成的浮点数。

format(value[, format_spec])：将value转换为format_spec控制的“格式化”表示。format_spec的解释取决于value实参的类型，但是大多数内置类型使用标准格式化语法。

class frozenset([iterable])：返回一个新的frozenset对象，它包含可选参数iterable中的元素。frozenset是一个内置的类。

getattr(object, name[, default])：返回对象命名属性的值。name必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， getattr(x, 'foobar') 等同于 x.foobar。如果指定的属性不存在，且提供了 default 值，则返回它，否则触发AttributeError。

globals()：返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。

hasattr(object, name)：实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回True，否则返回False。此功能是通过调用 getattr(object, name) 看是否有AttributeError异常来实现的。

hash(object)：返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如1和1.0）。注：hash()根据机器的字长来截断返回值。

help([object])：启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。

hex(x)：将整数转换为以“0x”为前缀的小写十六进制字符串。如果x不是Python int对象，则必须定义返回整数的__index__()方法。

id(object)：返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 id() 值。

input([prompt])：如果存在prompt实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到EOF时，则触发EOFError。如果加载了readline模块，input()将使用它来提供复杂的行编辑和历史记录功能。

class int([x])、class int(x, base=10)：返回一个使用数字或字符串x生成的整数对象，或者没有实参的时候返回 0。如果对象 x 定义了__int__()，int(x) 返回x.__int__()。如果 x 定义了 __trunc__()，它返回x.__trunc__()。对于浮点数，它向零舍入。
如果 x 不是数字，或者有 base 参数，x 必须是字符串、bytes、表示进制为 base 的整数字面值 的bytearray实例。该文字前可以有+或-（中间不能有空格），前后可以有空格。一个进制为n的数字包含0到n-1的数，其中 a 到 z （或 A 到 Z ）表示 10 到 35。默认的 base 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 0b/0B 、0o/0O 、0x/0X 前缀来表示。进制为0将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 int('010', 0) 是非法的，但int('010') 和 int('010', 8) 是合法的。

isinstance(object, classinfo)：如果object实参是classinfo实参的实例，或者是（直接、间接或虚拟）子类的实例，则返回true。如果object不是给定类型的对象，函数始终返回 false。如果classinfo是对象类型（或多个递归元组）的元组，如果object是其中的任何一个的实例则返回 true。如果classinfo既不是类型，也不是类型元组或类型的递归元组，那么会触发TypeError异常。

issubclass(class, classinfo)：如果class是 classinfo 的子类（直接、间接或虚拟的），则返回true。classinfo可以是类对象的元组，此时classinfo中的每个元素都会被检查。其他情况，会触发TypeError异常。

iter(object[, sentinel])：返回一个 iterator 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，object 必须是支持迭代协议（有__iter__()方法）的集合对象，或必须支持序列协议（有__getitem__()方法，且数字参数从 0 开始）。如果它不支持这些协议，会触发TypeError。如果有第二个实参 sentinel，那么 object 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的__next__()方法时都会不带实参地调用 object；如果返回的结果是sentinel则触发StopIteration，否则返回调用结果。适合 iter() 的第二种形式的应用之一是构建块读取器。

len(s)：返回对象的长度（元素个数）。实参可以是序列（如string、bytes、tuple、list或 range 等）或集合（如 dictionary、set 或 frozen set等）。

class list([iterable])：除了是函数，list也是可变序列类型。

locals()：更新并返回表示当前本地符号表的字典。在函数代码块但不是类代码块中调用locals()时将返回自由变量。请注意在模块层级上，locals() 和 globals() 是同一个字典。

map(function, iterable, ...)：产生一个将 function 应用于迭代器中所有元素并返回结果的迭代器。如果传递了额外的 iterable 实参，function 必须接受相同个数的实参，并使用所有迭代器中并行获取的元素。当有多个迭代器时，最短的迭代器耗尽则整个迭代结束。

max(iterable, *[, key, default])、max(arg1, arg2, *args[, key])：返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的元素。有两个可选只能用关键字的实参。key 实参指定排序函数用的参数，如传给list.sort()的。default 实参是当可迭代对象为空时返回的值，如果可迭代对象为空，并且没有给 default ，则会触发ValueError。
如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如sorted(iterable, key=keyfunc, reverse=True)和heapq.nlargest(1, iterable, key=keyfunc)保持一致。

memoryview(obj)：返回由给定实参创建的“内存视图”对象。

min(iterable, *[, key, default])、min(arg1, arg2, *args[, key])：返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。

next(iterator[, default])：通过调用iterator的__next__()方法获取下一个元素。如果迭代器耗尽，则返回给定的 default，如果没有默认值则触发StopIteration。

class object：返回一个没有特征的新对象。object是所有类的基类。它具有所有Python类实例的通用方法。这个函数不接受任何实参。

oct(x)：将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 x 不是 Python 的 int 对象，那它需要定义__index__()方法返回一个整数。

open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)：打开 file 并返回对应的 file object。如果该文件不能打开，则触发 OSError。Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。

ord(c)：对表示单个Unicode字符的字符串，返回代表它Unicode码点的整数。例如 ord('a') 返回整数 97， ord('€') （欧元符合）返回 8364 。这是chr()的逆函数。

pow(x, y[, z])：返回 x 的 y 次幂；如果 z 存在，则对z取余（比直接pow(x, y) % z计算更高效）。两个参数形式的 pow(x, y) 等价于幂运算符：x**y。参数必须为数值类型。 对于混用的操作数类型，则适用二元算术运算符的类型强制转换规则。

print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)：将objects打印到file指定的文本流，以sep分隔并在末尾加上end。sep, end, file 和 flush 如果存在，它们必须以关键字参数的形式给出。file参数不能用于二进制模式的文件对象，对于这些对象，应改用 file.write(...)。

class property(fget=None, fset=None, fdel=None, doc=None)：返回property属性。fget是获取属性值的函数。fset是用于设置属性值的函数。fdel是用于删除属性值的函数。并且doc属性为对象创建文档字符串。注意@property 装饰器。

range(stop)、range(start, stop[, step])：虽然被称为函数，但range实际上是一个不可变的序列类型。

repr(object)：返回包含一个对象的可打印表示形式的字符串。对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给eval()时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。类可以通过定义__repr__()方法来控制此函数为它的实例所返回的内容。

reversed(seq)：返回一个反向的iterator。seq 必须是一个具有__reversed__()方法的对象或者是支持该序列协议（具有从0开始的整数类型参数的__len__()方法和__getitem__()方法）。

round(number[, ndigits])：返回number舍入到小数点后ndigits位精度的值。如果ndigits被省略或为None，则返回最接近输入值的整数。

class set([iterable])：返回一个新的set对象，可以选择带有从iterable获取的元素。set 是一个内置类型。

setattr(object, name, value)：此函数与getattr()两相对应。其参数为一个对象、一个字符串和一个任意值。字符串指定一个现有属性或者新增属性。函数会将值赋给该属性，只有对象允许这种操作。例如，setattr(x, 'foobar', 123) 等价于 x.foobar = 123。

class slice(stop)、class slice(start, stop[, step])：返回一个表示由range(start, stop, step) 所指定索引集的slice对象。其中 start 和 step 参数默认为 None。slice切片对象具有仅会返回对应参数值start, stop 和 step（或其默认值）的只读数据属性。 它们没有其他的显式功能；不过它们会被NumP 以及其他第三方扩展所使用。切片对象也会在使用扩展索引语法时被生成。例如: a[start:stop:step] 或 a[start:stop, i]。

sorted(iterable, *, key=None, reverse=False)：根据iterable中的项返回一个新的已排序列表。具有两个可选参数，它们都必须指定为关键字参数。key指定带有单个参数的函数，用于从iterable的每个元素中提取用于比较的键 (例如 key=str.lower)。默认值为None(直接比较元素)。reverse 为一个布尔值。如果设为True，则每个列表元素将按反向顺序比较进行排序。使用 functools.cmp_to_key() 可将老式的 cmp 函数转换为 key 函数。内置的 sorted() 确保是稳定的。如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的，这有利于进行多重排序（例如先按部门、再按薪级排序）。

@staticmethod：将方法转换为静态方法。静态方法不会接收隐式的第一个参数。静态方法的调用可以在类上进行(例如 C.f())也可以在实例上进行(例如 C().f())。Python中的静态方法与Java或C++中的静态方法类似。也可以像常规函数一样调用 staticmethod ，并对其结果执行某些操作。

class str(object='')、class str(object=b'', encoding='utf-8', errors='strict')：返回一个str版本的 object。str是内置字符串class。

sum(iterable[, start])：从 start 开始自左向右对 iterable 中的项求和并返回总计值。start默认为 0。iterable 的项通常为数字，开始值则不允许为字符串。对某些用例来说，存在比sum()更好的替代。拼接字符串序列的更好更快方式是调用''.join(sequence)。要以扩展精度对浮点值求和，请参阅math.fsum()。要拼接一系列可迭代对象，请考虑使用itertools.chain()。

super([type[, object-or-type]])：返回一个代理对象，它会将方法调用委托给type指定的父类或兄弟类。这对于访问已在类中被重载的继承方法很有用。搜索顺序与 getattr() 所使用的相同，只是 type 指定的类型本身会被跳过。

tuple([iterable])：虽然被称为函数，但 tuple 实际上是一个不可变的序列类型。

class type(object)、class type(name, bases, dict)：传入一个参数时，返回object的类型。返回值是一个 type 对象，通常与object.__class__所返回的对象相同。推荐使用 isinstance() 内置函数来检测对象的类型，因为它会考虑子类的情况。传入三个参数时，返回一个新的 type 对象。这在本质上是 class 语句的一种动态形式。name 字符串即类名并且会成为__name__属性；bases元组列出基类并且会成为__bases__属性；而dict字典为包含类主体定义的命名空间并且会被复制到一个标准字典成为__dict__属性。

vars([object])：返回模块、类、实例或任何其它具有__dict__属性的对象的__dict__属性。模块和实例这样的对象具有可更新的__dict__属性；但是，其它对象的__dict__属性可能会设为限制写入（例如，类会使用 types.MappingProxyType 来防止直接更新字典）。不带参数时，vars() 的行为类似locals()。 请注意，locals仅用于读取，因此对locals字典的更新会被忽略。

zip(*iterables)：创建一个聚合了来自每个可迭代对象中的元素的迭代器。返回一个元组的迭代器，其中的第 i 个元组包含来自每个参数序列或可迭代对象的第 i 个元素。当所输入可迭代对象中最短的一个被耗尽时，迭代器将停止迭代，当只有一个可迭代对象参数时，它将返回一个单元组的迭代器。不带参数时，它将返回一个空迭代器。函数会保证可迭代对象按从左至右的顺序被求值。当你不用关心较长可迭代对象末尾不匹配的值时，则 zip() 只须使用长度不相等的输入即可。 如果那些值很重要，则应改用 itertools.zip_longest()。

__import__(name, globals=None, locals=None, fromlist=(), level=0)：此函数会由import语句发起调用。它可以被替换(通过导入builtins模块并赋值给builtins.__import__) 以便修改import语句的语义，但是强烈不建议这样做，因为使用导入钩子通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。同样也不建议直接使用__import__()而应该用importlib.import_module()。
