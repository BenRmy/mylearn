# 数据序列化/持久化

## pickle--Python对象序列化，最终是二进制序列化格式

该模块实现了对一个Python对象结构的二进制序列化和反序列化。"Pickling" 是将 Python 对象和所拥有的层次结构被转化为一个字节流的过程，而"unpickling"是相反的操作，会将（来自一个binary file或者bytes-like object 的）字节流转化回一个对象层次结构。注意：pickle模块在接受被错误地构造或者被恶意地构造的数据时不安全，永远不要unpickle来自于不受信任的或者未经验证的来源的数据。

pickle模块提供以下常量：

+ pickle.HIGHEST_PROTOCOL：整数，可用的最高协议版本。这个值可以作为一个被传递协议的价值函数dump()和dumps()以及Pickler构造函数。
+ pickle.DEFAULT_PROTOCOL：整数，用于酸洗的默认协议版本。小于HIGHEST_PROTOCOL。目前，默认协议是3，这是为Python3设计的新协议。

pickle模块提供以下功能，使酸洗过程更加方便：

+ pickle.dump(obj, file, protocol=None, *, fix_imports=True)：将pickled可序列化对象obj写入打开的文件对象中。protocol是可选的协议参数。如果fix_imports为true且protocol小于3，则pickle将尝试将新的Python3名称映射到Python2中使用的旧模块名称，以便使用Python2可读取pickle数据流。
+ pickle.dumps(obj, protocol=None, *, fix_imports=True)：将pickled对象作为bytes对象返回，而不是将其写入文件。
+ pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict")：从打开的文件对象中读取pickle对象表示，并返回其中指定的重构对象层次结构。
+ pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict")：从bytes对象读取pickle对象层次结构并返回其中指定的重构对象层次结构。

## json--JSON编码和解码器

JSON(JavaScript Object Notation)，是一个受 JavaScript 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集。

基本使用：

json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)：序列化obj为一个JSON格式的流并输出到fp（一个支持.write() 的file-like object）。json 模块始终产生 str 对象而非 bytes 对象。如果 skipkeys 是true（默认为 False），那么那些不是基本对象（包括 str, int、float、bool、None）的字典的键会被跳过；否则引发一个TypeError。如果ensure_ascii是true（即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 ensure_ascii是false，这些字符会原样输出。如果 check_circular是为false(默认为 True)，那么容器类型的循环引用检验会被跳过并且循环引用会引发一个OverflowError(或者更糟的情况)。如果 allow_nan 是 false（默认为 True），那么在对严格 JSON 规格范围外的 float 类型值（nan、inf 和 -inf）进行序列化时会引发一个 ValueError。如果 allow_nan 是 true，则使用它们的 JavaScript 等价形式（NaN、Infinity 和 -Infinity）。

json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)：将 obj 序列化为 JSON 格式的 str。 其参数的含义与 dump() 中的相同。

注：JSON 中的键值对的键永远是str类型的。当一个对象被转化为JSON时，字典中所有的键都会被强制转换为字符串。这所造成的结果是字典被转换为 JSON 然后转换回字典时可能和原来的不相等。

json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)：将fp(一个支持.read()并包含一个JSON文档的text file或者binary file)反序列化为一个 Python 对象。object_hook 是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 dict）。object_hook的返回值会取代原本的dict。这一特性能够被用于实现自定义解码器。

json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)：将str字符串反序列化为一个 Python 对象。
